<?xml version='1.0' ?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
               "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
<!ENTITY % myvars SYSTEM "../variables.ent">
%myvars;
]>

<sect1 id="ext-auth-requirements">
<title>External Authentication Requirements</title>
  <sect2><title>Vision</title>
    <para>People have plenty of usernames and passwords already, we
don&#39;t want them to have yet another. We want people to be able to
log in to OpenACS with the same password they use to log in to any
other system.</para>

    <para>Besides, administrators have better things to do than create
accounts for people. So we want them to be able to create just one
account on a central server (e.g. LDAP or RADIUS), and when they
log on to OpenACS, an account will automatically be created for
them here.</para>
    <para>Finally, security is increased with fewer passwords, since
users generally can&#39;t remember all those passwords, so they tend to
keep them all the same and never change them.</para>
  </sect2>
  <sect2 id="Design_Goal"><title>Design Goals</title>
    <itemizedlist>
      <listitem><para>Transparent: Users don&#39;t have to do anything special to
        get an account on the local OpenACS system, if they already have an
        account on the external authentication server.</para></listitem>
      <listitem><para>Fall-back: Users who don&#39;t have an account on the
        external authentication server are still allowed to create a local
        account on OpenACS. This could be for external students who should
        have access to .LRN, but not to the rest of the university&#39;s
        resources.</para></listitem>
      <listitem><para>Authentication Client Only: We want OpenACS to be able to
        authenticate by asking some remote authority to verify the user&#39;s
        username/password combination. The goal is explicitly <emphasis>not</emphasis> (at this
        point) to have OpenACS act as an authentication server for other
        systems, although this could be easily added later. The goal is
        also <emphasis>not</emphasis> to devise an infrastructure for letting OpenACS access
        resources in various other systems on the user&#39;s behalf, such as
        IMAP, iCalendar, SMB file servers, etc., although this is
        definitely an interesting use-case.</para></listitem>
      <listitem><para>Easy configuration: We would like people to be able to
        configure this without having to write code. In particular, we want
        to build drivers that know how to talk with LDAP, RADIUS, PAM,
        etc., and which won&#39;t have to be locally modified. Only
        configuration and policies should change, code should
        not.</para></listitem>
      <listitem><para>Usability: The solution must be easy to use for end users
        and administrators alike. There&#39;s frequently a positive feedback
        effect between usability and security, because when authentication
        schemes have poor usability, users will think up ways to circumvent
        them.</para></listitem>
      <listitem><para>Open and modular: The design should be on the one hand
        open to add other authentication mechanisms when needed and on
        the other hand very modular to enable a start with minimal
        requirements (driver implementations) as soon as
        possible.</para></listitem>
    </itemizedlist>
    <para>The problem can be split into several logically separate
parts. Each has a section below.</para>
  </sect2>

  <sect2 id="Terminology"><title>Terminology</title>
    <itemizedlist>
      <listitem><para>Authority: The name of an authority trusted to authenticate
        users.</para>
      </listitem>
      <listitem><para>Authentication Driver: An implementation of the
        authentication service contract, which talks to an authentication
        of a certain type, e.g. PAM, RADIUS, LDAP, or Active
        Directory.</para></listitem>
      <listitem><para>Authentication API: The API through which login pages and
        applications talk to the authentication service. There&#39;s one and
        only one implementation of the authentication API, namly the one
        included in OpenACS Core.</para></listitem>
      <listitem><para>Authentication Driver API: The service contract which
        authentication drivers implement.</para></listitem>
    </itemizedlist>
  </sect2>

  <sect2 id="Diagram"><title>Conceptual Pictures</title>
    <para>Authentication:</para>
    <para><inlinemediaobject><imageobject>
          <imagedata fileref="images/ext-auth.png"/>
        </imageobject></inlinemediaobject>
</para> 
<para>Account Management (NO PICTURE YET)</para>
<para>Batch Synchronization (NO PICTURE YET)</para>
  </sect2>

  <sect2 id="Requirements"><title>Requirements</title>

  <sect3>
  <title>New API</title>
    <segmentedlist>
      <?dbhtml list-presentation="req-table"?>
       <segtitle>New API</segtitle>
        <seglistitem>
          <seg>EXT-AUTH-01</seg>
          <seg>A</seg>
          <seg>Extend Authentication/Acct Status API</seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-03</seg>
          <seg>A</seg>
          <seg>Account Creation API</seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-05</seg>
          <seg>A</seg>
          <seg>Password Management API</seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-30</seg>
          <seg>A</seg>
          <seg>Authority Management API</seg>
        </seglistitem>
      </segmentedlist>
    </sect3>

    <sect3 id="Login"><title>Login</title>
      <segmentedlist>
        <?dbhtml list-presentation="req-table"?>
      <segtitle>Login</segtitle>
        <seglistitem>
          <seg>EXT-AUTH-04</seg>
          <seg>A</seg>
          <seg>Rewrite login, register, and admin pages to use APIs</seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-38</seg>
          <seg>A</seg>
          <seg>ad_form complain feature</seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-19</seg>
          <seg>A</seg>
          <seg>Rewrite password recovery to use API</seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-21</seg>
          <seg>A</seg>
          <seg>Rewrite email verification with API</seg>
          </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-28</seg>
          <seg>A</seg>
          <seg>Username is email switch</seg>
        </seglistitem>
      </segmentedlist>
      <para>Users will log in using a username, a authority, and a
      password.  The authority is the source for user/password
      verification.  OpenACS can be an authority itself. </para>
      
      <para>Each user in OpenACS will belong to exactly one authority, which
can either be the "local" OpenACS users table, in which case the
password column is used, or it can be some external authority,
which will be communicated with using some protocol, as implemented
by an authentication driver.</para>
      <para>Username will be separate from email address. It can be an
email address, it can look like an email address but not be the
name of an actual email mailbox, or it can be something else
entirely.</para>
      <para>We&#39;re assuming that user information (name, email, etc.) will
either already be in the users table through a batch
synchronization job, or that the relevant authentication
implementation supports real-time synchronization of user data.
Specifically, if you want remote users who haven&#39;t yet logged-in to
OpenACS to show up in user searches, you&#39;ll have to do the batch
synchronization.</para>
      <para>All in all, the login box will be an includeable template and
look like this:</para>
      <programlisting>
Username:  ________
Password:  ________
Authority: [URZ   ]
            Athena
            Local

[Forgot my password]
[New user registration]
</programlisting>
 
     
      <para>If there&#39;s only one active authority, we don&#39;t display the
authority drop-down element at all.</para>
    </sect3>

    <sect3 id="Configuratio"><title>Configuration</title>
      <segmentedlist>
        <segtitle>Configuration</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-07</seg>
          <seg>A</seg>
          <seg>Admin pages to control Ext-Auth parameters</seg>
        </seglistitem>
      </segmentedlist>
      <para>The site-wide systems administrator can configure the
authentication process from a page linked under /acs-admin.</para>
      <itemizedlist>
        <listitem><para>Authorities - ordered list of authorities defined</para></listitem>
        <listitem><para>Account Registration Allowed: Yes/No. Account
          registration can be disabled altogether.</para></listitem>
        <listitem><para>Registration authority - the authority in which accounts should
          be created, using the relevant driver, if account registration is
          allowed.</para></listitem>
        <listitem><para>Username is email? - instead of asking for username,
          we&#39;ll ask for email. And we&#39;ll store the value in both columns,
          username and email. This is a setting that spans all authorities, and
          is primarily meant for backwards compatibility with the old OpenACS
          login process.</para></listitem>
      </itemizedlist>
      <para>The local authority driver is an encapsulation of current
      functionality within an driver matching a service contract.  The
      other drivers call external functions.  The possible functions
      for each authority are split into several drivers for convenience.
      One driver handles authentication, one account creation, and one
      changing passwords.</para>
    

      <segmentedlist>
        <segtitle>create service contract</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-16</seg>
          <seg>A</seg>
          <seg>Create service contract for Authentication</seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-17</seg>
          <seg>A</seg>
          <seg>Create service contract for Acct. Creation</seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-29</seg>
          <seg>A</seg>
          <seg>Create service contract for Passwd Management</seg>
        </seglistitem>
      </segmentedlist>
      
      <segmentedlist>
          <segtitle> </segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-18</seg>
          <seg>A</seg>
          <seg>Authority configuration data model</seg>
          </seglistitem>
      </segmentedlist>
      <para>Each authority is defined like this:</para>
      <itemizedlist>
        <listitem><para>Authority pretty-name, e.g. "URZ"</para></listitem>
        <listitem><para>Authentication Driver, e.g. "RADIUS". In practice, this
          would be a reference to a service contract
          implementation.</para></listitem>
        <listitem><para>Authentication Driver configuration settings, e.g. host
          name, port, etc., as required by the particular driver. Note that
          this is per authority, not per driver, i.e., you can have multiple
          authorities with the same driver but different configuration
          options.</para></listitem>
        <listitem><para>AuthenticationAllowed - true/false, so you can disable
          login through some authority without having to delete the authority, and
          hence also all the users who belong to that authority.</para></listitem>
        <listitem><para>ForgottenPasswordUrl - a URL to redirect to instead of
          trying to use the authentication driver&#39;s password management
          features.</para></listitem>
        <listitem><para>ChangePasswordUrl - a URL to redirect to instead of
          trying to use the authentication driver&#39;s password management
          features.</para></listitem>
        <listitem><para>Account Creation Driver, e.g. "RADIUS". In practice, this
          would be a reference to a service contract implementation. The
          reason we have separate drivers for authentication and account
          creation is that organizations are likely to have a home-grown
          account registration process.</para></listitem>
        <listitem><para>Account Creation Driver configuration settings, e.g. host
          name, port, etc., as required by the particular driver. Note that
          this is per authority, not per driver, i.e., you can have multiple
          authorities with the same driver but different configuration
          options.</para></listitem>
        <listitem><para>RegistrationUrl - instead of registering using OpenACS,
          redirect to a certain URL site for account registration.</para></listitem>
        <listitem><para>RegistrationAllowed - true/false, so you can disable
          registration using this account.</para></listitem>
        <listitem><para>Sort order: Preference order of
        authorities.</para></listitem>
        <listitem><para>HelpContactText: Text or HTML to be displayed
        when user has trouble authenticating with the authority.
        Should include contact information such as a phone number or email.</para></listitem>
      </itemizedlist>
      <para>Each authority driver will have a set of configuration options
dependent on the driver, such as host, port, etc. We will need to
find a mechanism for the driver to tell us which configuration
options are available, a way to set these, and a way for the driver
to access these settings.</para>
      <para>OpenACS will come pre-configured with one authority, which is
the "local" authority, meaning we&#39;ll authenticate as normal using the
local users table. This will, just like any other authority, be
implemetned using a service contract.</para>
    </sect3>

    <sect3 id="Synchronizing_and_Linking_User"><title>Synchronizing
and Linking Users</title>
      <segmentedlist>
        <segtitle>Synchronizing and linking users</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-28</seg>
          <seg>A</seg>
          <seg>Create service contract for Batch Sync.</seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-38</seg>
          <seg>A</seg>
          <seg>Batch User Synchronization API</seg>
        </seglistitem>

        <seglistitem>
          <seg>EXT-AUTH-38</seg>
          <seg>A</seg>
          <seg>IMS Synchronization driver</seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-08</seg>
          <seg>A</seg>
          <seg>Automation of batch Synchronization</seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-15</seg>
          <seg>B</seg>
          <seg>On-demand synchronization</seg>
        </seglistitem>
      </segmentedlist>
      
      <para>Regardless of the login method, the user needs to have a row
in the OpenACS users table. This can happen through a batch job, in
real-time, or both in combination.  We use the <ulink
url="https://www.imsglobal.org/enterprise/index.html">IMS Enterprise 1.1</ulink> specification. </para>
      <para>Batch job means that we do a synchronization (import new
users, modify changed, purge deleted) on a regular interval, e.g.
every night. You can also decide to have a monthly full
synchronization, plus daily incremental ones. That&#39;s up to you. The
advantage is that you have all users in OpenACS, so when you search
for a user, you&#39;ll see all the organization&#39;s users, not just those
who happen to have used the OpenACS-based system. The down-side is
that it takes some time for user information to propagate. This can
be remedied by using the real-time solution.  The batch job will also
require error logging and an admin interface to view logs.</para>
      <para>If an email already belongs to some
other user, we log it as an error.</para>
      <para>A user will always belong to exactly one authority, which can be
either the "local" authority or some other. Thus, the OpenACS user&#39;s
table will have to be augmented with the following columns:</para>
      <itemizedlist>
        <listitem><para>Authority. Reference to the site-wide authorities list. The
          authority which can authenticate this user.</para></listitem>
        <listitem><para>Authority-specific username.</para></listitem>
      </itemizedlist>
      <para>Real-time means that the first time the user logs into
OpenACS, we&#39;ll query the authority that authenticated him
for information about this user. That authentication authority will
then give us at least first names, last name and email. The pros
and cons are the opposite of batch jobs. Using both in combination
is ideal.</para>
      <para>Note: One solution to the "two users from different authorities
have the same email" problem above would be to allow users to
belong to multiple authorities. Then we would notice that the email
already exists, ask the user if he thinks he&#39;s the same person, and
if so, ask him to prove so by authenticating using the other
authority. Thus he&#39;ll have just authenticated in two different
authorities, and we can record that this is the same person. We&#39;d still
have a problem if there was an email conflict between two accounts
on the same authority. Hm. I don&#39;t think it&#39;s worth spending too much
time trying to solve this problem through software.</para>
      <segmentedlist>
        <segtitle>EXT-AUTH-31</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-31</seg>
          <seg>A</seg>
          <seg>Upgrade user data model for ext-auth</seg>
          </seglistitem>
      </segmentedlist>
      <para>After having authenticated using the relevant authority driver,
we&#39;ll look for the username/authority pair in the users table.</para>
      <para>If we don&#39;t find any, that means that we&#39;re either not doing
batch synchronizing, or that the user has been added since the last
sync. In that case, we&#39;ll try to do a real-time synchronization, if
the driver supports it. If it does, it&#39;ll return email,
first_names, last_name, and other relevant information, and we&#39;ll
create a row in the local users table using that
information.</para>
      <para>If that doesn&#39;t work, we&#39;ll tell the user that their account
isn&#39;t yet available, and the driver will supply a message for us,
which could say "The account should be available tomorrow. If not,
contact X."</para>
    </sect3>

    <sect3 id="Account_Registratio"><title>Account
Registration</title>
      <para>If a user doesn&#39;t have an account, the site-wide
configuration can allow the user to register for one, as defined in
the configuration discussed above. This section is about normal
account registration through a authority driver.</para>
      <para>The account creation service contract implementation will
need to tell us which information to ask the user for:</para>
      <itemizedlist>
        <listitem><para>Required Fields: A list of fields which are
          required.</para></listitem>
        <listitem><para>Optional Fields: A list of fields which are
          optional.</para></listitem>
      </itemizedlist>
      <para>The fields to choose from are these:</para>
      <itemizedlist>
        <listitem><para>Username</para></listitem>
        <listitem><para>First names</para></listitem>
        <listitem><para>Last name</para></listitem>
        <listitem><para>Email</para></listitem>
        <listitem><para>URL</para></listitem>
        <listitem><para>Password</para></listitem>
        <listitem><para>Secret question</para></listitem>
        <listitem><para>Secret answer</para></listitem>
      </itemizedlist>
      <para>It should return the following:</para>
      <itemizedlist>
        <listitem><para>Creation status (OK, Try-Again, Fail)</para></listitem>
        <listitem><para>Creation message: What went wrong, or a welcome
          message.</para></listitem>
        <listitem><para>Account status: Is the account ready for use?</para></listitem>
        <listitem><para>User information: first_names, last_name, email, url,
          password, password_hash, secret_question, secret_answer. The driver
          only needs to return the columns which were changed or added
          through the registration process. Typically, only the "local"
          driver will return password and secret question/answer.</para></listitem>
      </itemizedlist>
      <para>After creating the remote account, a local account is created
with the information gathered through the form/returned by the
driver.</para>
      <para>By default, a local account creation implementation is
provided, which will create a new OpenACS user, and, in addition to
the default local account creation above, also store the password
in hashed form.</para>
    </sect3>

    <sect3 id="Password_Managemen"><title>Password
Management</title>
      <para>Password management is about changing password, retrieving
password, and resetting password.</para>
      <para>It&#39;s up to the authority driver implementation to decide whether
to support any or all of these features, and to say so using the
CanXXX methods (see driver API below).</para>
      <para>Additionally, the authority can be configured with a URL to
redirect to in the case of forgotten passwords, or when the user
desires to change password.</para>
    </sect3>

    <sect3 id="Login_Pages_Over_HTTP"><title>Login Pages Over
HTTPS</title>
      <segmentedlist>
        <segtitle>EXT-AUTH-20</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-20</seg>
          <seg>A</seg>
          <seg>Login over HTTPS</seg>
          </seglistitem>
      </segmentedlist>
      <para>Login pages must be able to be sent over a secure connection
(https), so your password won&#39;t get sent over the wire in
cleartext, while leaving the rest of the site non-secure (http). I
believe that this requires some (minor) changes to the current
session handling code.</para>
    </sect3>

    <sect3 id="Email_Verificatio"><title>Email
Verification</title>
      <para>Email verification needs to be handled both at registration
and at login.</para>
      <para>In both cases, it&#39;ll be handled by the driver sending
automatically sending the email containing a link for the user to
verify his account. Then the driver will return an account status
of "closed,temporary", and a message that says "Check your inbox
and click the link in the email".</para>
      <para>OpenACS will have a page which receives the email
verification, for use by local accounts. Other authorities will
have to implement their own page, most likely on the authority&#39;s
own server.</para>
    </sect3></sect2>

  <sect2 id="Other_Item"><title>Other Items</title>
    <para>There are a number of items which touch on external
authentication and session management. And even though they&#39;re not
directly linked to external authentication, I would recommend that
we handle a number of them, either because they&#39;re important for
security, or because it makes sense to fix them while we&#39;re messing
with this part of the codebase anyway.</para>


    <sect3 id="Recommended__Untrusted_Logins_and_Login_Leve"><title>Recommended:
Untrusted Logins and Login Levels</title>
      <segmentedlist>
        <segtitle>EXT-AUTH-33</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-33</seg>
          <seg>A</seg>
          <seg>Untrusted Logins</seg>
        </seglistitem>
      </segmentedlist>
      <para>I like the idea of having multiple login levels:</para>
      <orderedlist>
        <listitem><para>Not logged-in</para></listitem>
        <listitem><para>Untrusted login: We&#39;ll show you un-sensitive personal
          content, but won&#39;t let you modify anything or see personal data. A
          normal login becomes untrusted after a certain amount of time, and
          the user will have to re-enter his/her password in order to gain
          access to personal data. Untrusted login never expires, unless
          explicitly done so through either changing password or clicking a
          special "expire all logins" link.</para></listitem>
        <listitem><para>Normal login: The user is logged-in, and has type his
          password sufficiently recently that we trust the login. All normal
          operations are allowed. Will degrade to untrusted login after a
          specified amount of time.</para></listitem>
        <listitem><para>Secure login: The user is logged-in over a secure
          connection (HTTPS), potentially even using a special secure
          password. This would be for sensitive actions, such as credit card
          transactions.</para></listitem>
        </orderedlist>
      <para>There are two advantages to this. First, when people&#39;s login
expires, we can ask them to re-enter only their password, and not
both username and password, since we&#39;ll still remember who they
were the last time their login was valid. This is a much faster
operation (the password input field will be focused by default, so
you just type your password and hit Return) that typing both
username and password, which will make it practical to have your
site configured to expire people&#39;s login after e.g. 2, 4, or 8
hours.</para>
      <para>The other advantage is that we can still offer certain
functionality to you, even when your login is not trusted. For
example, we could let you browse publicly available forums, and
only when you want to post do you need to log in. This makes it
even more feasible to have a more secure login expiration
setting.</para>
      <para>By default, <literal>auth::require_login</literal> would
bounce to the login page if the user is only logged-in at the
untrusted level. Only if you explicitly say
<literal>auth::require_login -untrusted</literal> will we give you
the user_id of a user who&#39;s only logged-in in untrusted
mode.</para>
      <para>Similarly, <literal>ad_conn user_id</literal> will continue
to return 0 (not logged-in) when the user is only logged-in
untrusted, and we&#39;ll supply another variable, <literal>ad_conn
untrusted_user_id</literal>, which wlll be set to the user_id for
all login levels.</para>
      <para>This should ensure that we get full access to the new
feature, while leaving all current code just as secure as it was
before.</para>
    </sect3>

    <sect3 id="Recommended__Make_Non-Persistent_Login_Wor"><title>Recommended:
Make Non-Persistent Login Work</title>
      <segmentedlist>
        <segtitle>EXT-AUTH-34</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-34</seg>
          <seg>A</seg>
          <seg>Expire Logins</seg>
        </seglistitem>
      </segmentedlist>
      <para>Currently, OpenACS is unusable in practice without persistent
login. The login will expire after just a few minutes of
inactivity, and you&#39;ll get bounced to the login page where you have
to enter both email and password again. Unacceptable in
practice.</para>
      <para>We should change the default, so a non-persistent login
doesn&#39;t expire until you either close your browser, or a few hours
have elapsed. Even if you are constantly active, the login should
still expire after at most x number of hours. We can still make the
login expire after a period of inactivity, but the amount of time
should be configurable and default to something reasonable like an
hour or so.</para>
      <para>This will require looking into and changing the design of the
current session handling code.</para>
    </sect3>

    <sect3 id="Recommended__Single-Sign-O"><title>Recommended:
Single-Sign-On</title>
      <segmentedlist>
        <segtitle>EXT-AUTH-23</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-23</seg>
          <seg></seg>
          <seg>Single sign-on</seg>
          </seglistitem>
      </segmentedlist>
      <para>Instead of redirecting to the login page, auth::require_login
can redirect to an authentication server, which can redirect back
to a page that logs the user in. This should be very easy to
implement.</para>
      <para>Alternatively, if you want to combine this with fallback to
OpenACS accounts, we would instead present the normal login screen,
but put a button which says "Login using X", where X is the
redirection-based external authority.</para>
    </sect3>

    <sect3 id="Recommended__Expire_All_Login"><title>Recommended:
Expire All Logins</title>
      <segmentedlist>
        <segtitle>EXT-AUTH-22</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-22</seg>
          <seg>B</seg>
          <seg>rewrite cookie handling</seg>
          </seglistitem>
      </segmentedlist>
      <para>Currently, if you&#39;ve ever left a permanent login cookie on
someone elses machine, that person will be forever logged-in until
he/she explicitly logs out. You can change your password, you can
do anything you want, but unless a logout is requested from that
particular browser, that browser will be logged-in forever.</para>
      <para>I want to change our session handling code so that old login
cookies can be expired. This would be done automatically whenever
you change your password, and we could also offer a link which does
this without changing passwords. It&#39;s an important security
measure.</para>
      <para>The implementation is simply to autogenerate some secret
token which is stored in the users table, and is also stored in the
cookie somehow. Then, whenever we want to expire all logins, we&#39;ll
just regenerate a new secret token, and the other cookies will be
void. Of course, we don&#39;t want to incur a DB hit on every request,
so we&#39;ll need to cache the secret token, or only check it when
refreshing the session cookie, which, I believe, normally happens
every 10 minutes or so.</para>
    </sect3>

    <sect3 id="Recommended__Email_account_owner_on_password"><title>Recommended:
Email account owner on password change</title>
      <segmentedlist>
        <segtitle>EXT-AUTH-24</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-24</seg>
          <seg>A</seg>
          <seg>Email on password change</seg>
          </seglistitem>
      </segmentedlist>
      <para>As an additional security measure, we should email the
account&#39;s email address whenever the password is changed, so that
he/she is at least alerted to the fact.</para>
    </sect3>

    <sect3 id="Optional__Password_polic"><title>Optional:
Password policy</title>
      <segmentedlist>
        <segtitle>EXT-AUTH-25</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-25</seg>
          <seg>A</seg>
          <seg>Implement password policy</seg>
          </seglistitem>
      </segmentedlist>
      <para>Again, to increase security, we should add password policies,
such as passwords needing to be changed after a certain number of
days, change on next login (after a new random password has been
generated), or requiring that the password satisfies certain
complexity rules, i.e. both upper and lowercase characters,
numbers, special chars, etc.</para>
      <para>It would good to extend the current maximum password length
from 10 to at least 32 characters.</para>
    </sect3>

    <sect3 id="Optional__Login_Without_Explicit_Domai"><title>Optional:
Login Without Explicit Authority</title>
      <segmentedlist>
        <segtitle>EXT-AUTH-26</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-26</seg>
          <seg>B</seg>
          <seg>Login without explicit domain</seg>
          </seglistitem>
      </segmentedlist>
      <para>In order to make it easier for people, we&#39;ve been toying with
the idea of a functionality like this:</para>
      <itemizedlist>
        <listitem><para>If the user enters "foobar@ix.urz.uni-heidelberg.de", it
          is translated to mean username = "foobar", authority =
          "ix.urz.uni-heidelberg.de".</para></listitem>
        <listitem><para>If the user enters "foobar", it&#39;s recognized to not
          include any authority, and the default authority of
          "ix.urz.uni-heidelberg.de" is used.</para></listitem>
        <listitem><para>If the user enters "foo@bar.com", it&#39;s recognized as not
          belonging to any known authority, and as such, it&#39;s translated to mean
          username = "foo@bar.com", authority = "local".</para></listitem>
      </itemizedlist>
      <para>If this is deemed desirable, a way to implement this would be
through these settings:</para>
      <itemizedlist>
        <listitem><para>Split: A regexp which will split the user&#39;s entry into
          username and authority parts. For example "^([^@]+)(@[^@]+)?$". An
          easier to use but less flexible method would be that you simply
          specify a certain character to split by, such as "@" or "\". If the
          regexp doesn&#39;t match, or in the latter case, if there&#39;s more than
          one occurrence of the specified character sequence, the split will
          fail, signaling that the user&#39;s entry was not valid.</para></listitem>
        <listitem><para>Default authority: The default authority will be the first one
          in the sort order.</para></listitem>
      </itemizedlist>
      <para>The relevant code in user-login.tcl would look like
this:</para>
      <programlisting>
if { ![auth::split_username -username_var username -authority_var authority] } {
    # bounce back to the form with a message saying that the login wasn&#39;t valid.
    ad_script_abort
}

# username will now contain username
# authority will now contain authority
</programlisting>

    </sect3>


    <sect3 id="Optional__Whois_Onlin"><title>Optional: Who&#39;s Online</title>
      <segmentedlist>
        <segtitle>EXT-AUTH-27</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-27</seg>
          <seg>B</seg>
          <seg>Who&#39;s online list</seg>
          </seglistitem>
      </segmentedlist>
      <para>While we&#39;re touching the session handling code, anyway, it
would be nice to add a feature to show who&#39;s currently online, a
nice real-time collaboration feature frequently requested by
members of the community. This is particularly interesting when
integrated with a chat or instant messaging service like
Jabber.</para>
      <para>What I&#39;m concretely suggesting is that we keep a record of
which authenticated users have requested pages on the site in the
last x minutes (typically about 5), and thus are considered to be
currently online. There&#39;s nothing more to it. This lets us display
a list of "active users" somewhere on the site, and make their name
a link to a real-time chat service like Jabber.</para>
      <para>We&#39;ve already made the changes necessary to
security-procs.tcl to do this on an earlier project, but haven&#39;t
quite finished the work and put it back into the tree.</para>
    </sect3>

    <sect3 id="Optional__Subsite-level_configuratio"><title>Optional:
Subsite-level configuration</title>
      <segmentedlist>
        <segtitle>EXT-AUTH-28</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-28</seg>
          <seg></seg>
          <seg>implement subsite-level config</seg>
          </seglistitem>
      </segmentedlist>
      <para>If we want to, we could let subsite administrators configure
the login process for that particular subsite. This would probably
only entail letting the subsite admin leave out certain authorities
defined site-wide, and change the sort order.</para>
      <para>I think we should leave this out until we have a use case for
it, someone who&#39;d need it.</para>
    </sect3>

    <sect3 id="Future__Making_the_Authentication_API_itself"><title>Future:
Making the Authentication API itself a service contract</title>
      <segmentedlist>
        <segtitle>EXT-AUTH-32</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-32</seg>
          <seg>A</seg>
          <seg>Parameters for Service Contract Implementation</seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-35</seg>
          <seg>A</seg>
          <seg>Make the Authentication API a service contract</seg>
        </seglistitem>
      </segmentedlist>
      <para>For completely free-form authentication logic and mechanisms,
something like Andrew Grumet&#39;s
<ulink url="http://openacs.org/new-file-storage/download/oacs-pam.html?version_id=687">Pluggable
Authentication for OACS Draft</ulink> is interesting. He&#39;s
proposing a scheme where the entire user interaction is
encapsulated in, and left entirely to, a service contract. This
certainly opens up more advanced possibilities, such as perhaps
smart cards, personal certificates, etc.</para>
      <para>I have chosen not to go this route, because I think that most
people are going to want to use a username/password-based scheme,
and having easy configuration through a web UI is more important
than total flexibility at this point.</para>
      <para>Besides, we can always do this in the future, by letting the
public Authentication API (<literal>auth::require_login</literal>
and <literal>auth::authenticate</literal>) be implemented through a
service contract.</para>
    </sect3>

    <sect3 id="Future__Authenticating_against_multiple_serv"><title>Future:
Authenticating against multiple servers simultaneously</title>
      <segmentedlist>
        <segtitle>EXT-AUTH-36</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-36</seg>
          <seg>A</seg>
          <seg>Authenticate against multiple servers</seg>
        </seglistitem>
      </segmentedlist>
      <para>Both OKI and OpenACS supports a form of stacking, where you
can be logged into multiple authorities at the same time. This is
useful if, for example, you need to get login tokens such as
Kerberos tickets for access to shared resources.</para>
      <para>I can see the value in this, but for simplicity&#39;s sake, I&#39;m
in favor of keeping this use-case out of the loop until we have
someone with a real requirement who could help us guide
development.</para>
      <para>For now, OpenACS is still more of an integrated suite, it
doesn&#39;t access many outside applications. I think it would be
excellent for OpenACS to do so, e.g. by using an IMAP server to
store emails, an iCal server to store calendar appointments, LDAP
for user/group data and access control lists, SMB for file storage,
etc. But at the moment, we don&#39;t have any users of such things that
are ready. We have some who are on the steps, but let&#39;s wait till
they&#39;re there.</para>
    </sect3>
    <sect3 id="Implement_Specific_Driver">
      <title>Implement
Specific Drivers</title>
      <segmentedlist>
        <segtitle>Implement specific drivers</segtitle>
        <?dbhtml list-presentation="req-table"?>
        <seglistitem>
          <seg>EXT-AUTH-09</seg>
          <seg>A</seg>
          <seg>Create Auth. drivers for Local Authority</seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-10</seg>
          <seg>A</seg>
          <seg>Create Acct. Creation driver for Local Authority</seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-11</seg>
          <seg>A</seg>
          <seg>Create Auth. driver for PAM</seg>
        </seglistitem>
        <seglistitem>
            <seg>EXT-AUTH-12</seg>
            <seg>X</seg>
            <seg><emphasis>Create Acct. Creation driver for PAM - this
          functionality is explicitly excluded from PAM</emphasis></seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-13</seg>
          <seg>A</seg>
          <seg>Create Acct. Creation driver for LDAP</seg>
        </seglistitem>
        <seglistitem>
          <seg>EXT-AUTH-14</seg>
          <seg>A</seg>
          <seg>Create Auth. driver for LDAP</seg>
        </seglistitem>
      </segmentedlist>
      <para>We&#39;ll need drivers for:</para>
      <itemizedlist>
        <listitem><para>Operating system (Linux/Solaris) PAM: Delegate to the
          operating system, which can then talk to RADIUS, LDAP, whatever.
          This is convenient because there&#39;ll be plenty of drivers for the OS
          PAM level, so we don&#39;t have to write them all ourselves. The
          downside is that we can&#39;t do things like account creation, password
          management, real-time account synchronization, etc., not supported
          by PAM (I&#39;m not entirely sure what is and is not
          supported).</para></listitem>
        <listitem><para>RADIUS</para></listitem>
        <listitem><para>LDAP</para></listitem>
      </itemizedlist>
      <sect4 id="RADIU"><title>RADIUS</title>
        <para>RADIUS is a simple username/password-type authentication
server.</para>
        <para>It also supports sending a challenge to which the user must
respond with the proper answer (e.g. mother&#39;s maiden name, or could
be additional password), but we will not support this
feature.</para>
        <para>A RADIUS client
<ulink url="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/exuserfolder/exUserFolder/radiusAuthSource/radius.py?rev=1.4&amp;content-type=text/vnd.viewcvs-markup">implementation
in Python</ulink> can be found in the
<ulink url="http://exuserfolder.sourceforge.net/">exUserFolder
module</ulink> for Zope
(<ulink url="http://sourceforge.net/docman/display_doc.php?docid=7238&amp;group_id=36318">documentation</ulink>).</para>
      </sect4>
    </sect3>
  </sect2>

  <sect2 id="Feedbac"><title>Feedback</title>
    <para>We&#39;d really appreciate feedback on this proposal. Please follow up at
<ulink url="http://openacs.org/forums/message-view?message_id=97341">this
openacs.org forums thread</ulink>.</para>
  </sect2>

  <sect2 id="Reference"><title>References</title>
    <itemizedlist>
      <listitem>
        <para>      <ulink url="https://www.imsglobal.org/enterprise/index.html/">IMS Enterprise</ulink></para>
      </listitem>
      <listitem><para><ulink url="http://openacs.org/projects/openacs/packages/ex-auth/">Threads
and links</ulink> collected by Carl Blesius.</para></listitem>
      <listitem><para><ulink url="http://java.sun.com/security/jaas/doc/pam.html">Solaris/Linux
PAM specification</ulink></para></listitem>
      <listitem><para><ulink url="http://openacs.org/new-file-storage/download/oacs-pam.html?version_id=687">Draft
Proposal</ulink> by Andrew Grumet.</para></listitem>
      <listitem><para><ulink url="http://www.yale.edu/tp/auth/">Yale
CAS</ulink>, a central authentication service a' la
        Passport.</para></listitem>
    </itemizedlist>
    </sect2>
  <sect2 id="ext-auth-revision-history">
  <title>Revision History</title>

   <informaltable>
     <tgroup cols="4">
     <tbody>
       <row>
         <entry><emphasis role="strong">Document Revision #</emphasis></entry>
         <entry><emphasis role="strong">Action Taken, Notes</emphasis></entry>
         <entry><emphasis role="strong">When?</emphasis></entry>
         <entry><emphasis role="strong">By Whom?</emphasis></entry>
      </row>

      <row>
        <entry>1</entry>
        <entry>Updated work-in-progress for consortium-sponsored ext-auth work at Collaboraid.</entry>
        <entry>20 Aug 2003</entry>
        <entry>Joel Aufrecht</entry>
      </row>
        </tbody>
      </tgroup>
    </informaltable>
  </sect2>
</sect1>

